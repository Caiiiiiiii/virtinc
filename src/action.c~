#ifndef _H_ACTION_
#define _H_ACTION_

#include "defs.h"
#include "calc_math.h"

#ifndef amin
#define amin(x, y) ((x) > (y) ? (x) : (y))
#endif

void sw_send(ip_pcb_t *ip, int port) {
  int length = ((ip_header_t *)ip)->length;
  ((ip_header_t *)ip)->checksum = 0;
  ((ip_header_t *)ip)->checksum = compute_checksum(ip, length);
  int ret = pcap_inject(pcap_handle_group[port - 1], ip, length);
  if(ret != length)
    perror("packet damage: ");
  send_packet_num++;
}

void sw_send_ack(ip_pcb_t *ip, int port) {
  ip_pcb_t sd;
  memcpy(&sd, ip, sizeof(ip_pcb_t));
  sd.ip_head.src_ip = (ip->ip_head).dst_ip;
  sd.ip_head.dst_ip = (ip->ip_head).src_ip;
  ((incp_header_t *)(sd.data))->flag = 1;
  ((incp_header_t *)(sd.data))->payload_length = 0;
  ((in_pcb_t *)(sd.data))->data[0] = 0;
  sd.ip_head.length = sizeof(ip_header_t) + sizeof(incp_header_t);
  sw_send(&sd, port);
}

void calc_load_send(ip_pcb_t *ip, char *data, int seq) {
  memset(ip, 0, sizeof(ip_pcb_t));
  ((incp_header_t *)(ip->data))->flag = 7;
  ((incp_header_t *)(ip->data))->seq_num = seq;
  ((incp_header_t *)(ip->data))->payload_length = INCP_PAYLOAD;
  memcpy(((in_pcb_t *)(ip->data))->data, data, INCP_PAYLOAD);
  ip->ip_head.length = sizeof(ip_header_t) + sizeof(incp_header_t) + INCP_PAYLOAD;
  sw_send(ip, 1);
}

void generate_key(uint8 *key) {
  memset(key, 0xFF, INCP_PAYLOAD);
}


void calc_pre_send(ip_pcb_t *ip, int port) {
  agg_p = 0;
  for(int i = 0; i < WINDOW_SIZE && i < total_packets; ++i) {
    memset(&agg_buffer[i], 0, sizeof(ip_pcb_t));
    ((incp_header_t *)(agg_buffer[i].data))->flag = 7;
    ((incp_header_t *)(agg_buffer[i].data))->seq_num = i;
    ((incp_header_t *)(agg_buffer[i].data))->payload_length = INCP_PAYLOAD;
    agg_buffer[i].ip_head.length = sizeof(ip_header_t) + sizeof(incp_header_t) + INCP_PAYLOAD;
    generate_key(((in_pcb_t *)(ip->data))->data);
    agg_flag[i] = 3;
    agg_time[i] = clock();
    agg_port[i] = port;
    sw_send(&agg_buffer[i], port);
  }
}

int action_nop(ip_pcb_t *ip, int port) {
  printf("--> %s\n", __FUNCTION__);
  sw_send(ip, port);
  return 0;
}

int action_clear(ip_pcb_t *ip, int port) {
  printf("--> %s\n", __FUNCTION__);
  in_pcb_t *incp = (in_pcb_t *)(ip->data);
  ((incp_header_t *)incp)->payload_length = 0;
  incp->data[0] = 0;
  ((ip_header_t *)ip)->length = sizeof(ip_header_t) + sizeof(incp_header_t);
  sw_send(ip, port);
  return 0;
}

/*******************************************************
 * src --------------|       |->src---copy-|
 *                   |--xor--|             |
 * agg_buffer(calc) -|                     |->agg_buffer
 *
 * return -1: drop
 * return 0: send ACK to src
 * return x: send ACK to src
 *           send result(agg_buffer[x-1]) to next stop
 ******************************************************/
int action_aggregation_src(ip_pcb_t *ip, int port) {
  in_pcb_t *incp = (in_pcb_t *)(ip->data);
  int p = ((incp_header_t *)incp)->seq_num;
  printf("--> %s, seq_num = %d, win_front = %d\n", __FUNCTION__, p, agg_p);
  int front = agg_p;
  int back = amin(agg_p + WINDOW_SIZE, total_packets);
  if(p < front || p >= back) // out range
    return -1;
  p = p % WINDOW_SIZE;
  sw_send_ack(ip, port);
  if(agg_flag[p] & 1) // repate
    return -1;
  if(agg_flag[p] == 0) {
    agg_flag[p] = 1;
    agg_port[p] = port ^ 2;
    memcpy(&agg_buffer[p], ip, sizeof(ip_pcb_t));
    return 1;
  }
  char *data1 = incp->data;
  char *data2 = ((in_pcb_t *)(agg_buffer[p].data))->data;
  for(int i = 0; i < (incp->incp_head).payload_length; ++i)
    data1[i] ^= data2[i];
  memcpy(&agg_buffer[p], ip, sizeof(ip_pcb_t));
  agg_port[p] = port ^ 2;
  agg_time[p] = clock();
  agg_flag[p] = 3;
  sw_send(&agg_buffer[p], agg_port[p]);
  return 2;
}

int action_sw_ack(ip_pcb_t *ip, int port) {
  printf("--> %s\n", __FUNCTION__);
  in_pcb_t *incp = (in_pcb_t *)(ip->data);
  int p = ((incp_header_t *)incp)->seq_num;
  printf("--> %s, seq_num = %d\n", __FUNCTION__, p);
  int front = agg_p;
  int back = amin(agg_p + WINDOW_SIZE, total_packets);
  if(p < front || p >= back)
    return 0;
  p %= WINDOW_SIZE;  
  agg_flag[p] |= 4;
  while(agg_p != total_packets && agg_flag[agg_p % WINDOW_SIZE] == 7) {
    agg_flag[agg_p % WINDOW_SIZE] = 0;
    ++agg_p;
  }
  return -1;
}  

/*******************************************************
 * calc -------------|       |->src
 *                   |--xor--|       
 * agg_buffer(src) --|               
 *
 * return -1: drop
 * return 0: send ACK to src
 * return x: send ACK to src
 *           send result(agg_buffer[x-1]) to next stop
 ******************************************************/
int action_aggregation_calc(ip_pcb_t *ip, int port) {
  in_pcb_t *incp = (in_pcb_t *)(ip->data);
  int p = ((incp_header_t *)incp)->seq_num;
  int front = agg_p;
  int back = amin(agg_p + WINDOW_SIZE, total_packets);
  printf("--> %s, seq_num = %d, win_front = %d\n", __FUNCTION__, p, agg_p);
  if(p < back)
    sw_send_ack(ip, port);
  if(p < front || p >= back) // out range
    return -1;
  p = p % WINDOW_SIZE;
  if(agg_flag[p] & 2) // repate
    return -1;
  if(agg_flag[p] == 0) {
    agg_flag[p] = 2;
    memcpy(&agg_buffer[p], ip, sizeof(ip_pcb_t));
    return 0;
  }
  char *data1 = incp->data;
  char *data2 = ((in_pcb_t *)(agg_buffer[p].data))->data;
  for(int i = 0; i < (incp->incp_head).payload_length; ++i)
    data2[i] ^= data1[i];
  agg_time[p] = clock();
  agg_flag[p] = 3;
  sw_send(&agg_buffer[p], agg_port[p]);
  return 2;
}

int action_calc_ack(ip_pcb_t *ip, int port) {
  uint8 tmp[INCP_PAYLOAD];
  in_pcb_t *incp = (in_pcb_t *)(ip->data);
  int p = ((incp_header_t *)incp)->seq_num;
  printf("--> %s, seq_num = %d\n", __FUNCTION__, p);
  int front = agg_p;
  int back = amin(agg_p + WINDOW_SIZE, total_packets);
  if(p < front || p >= back)
    return -1;
  p %= WINDOW_SIZE;
  agg_flag[p] = 7;
  while(agg_p != total_packets && agg_flag[agg_p % WINDOW_SIZE] == 1) {
    agg_flag[agg_p % WINDOW_SIZE] = 0;
    if(agg_p + WINDOW_SIZE <= total_packets) {
      generate_key(tmp);
      calc_load_send(&agg_buffer[agg_p % WINDOW_SIZE], tmp, agg_p + WINDOW_SIZE);
      agg_port[agg_p % WINDOW_SIZE] = 1;
      agg_flag[agg_p % WINDOW_SIZE] = 3;
      agg_time[agg_p % WINDOW_SIZE] = clock();
    }
    ++agg_p;
  }
  return 0;
}
  

// load p, g, g^a
int action_load_a(ip_pcb_t *ip, int port) {
  in_pcb_t *incp = (in_pcb_t *)(ip->data);
  total_packets = (incp->incp_head).seq_num;
  sw_send(ip, port);
  printf("--> %s, tot = %d\n", __FUNCTION__, total_packets);
  return 0;
  calc_generate_p_g_a(key_p, key_g, key_a);
  memcpy(incp->data, key_p, KEY_SIZE);
  memcpy(incp->data + KEY_SIZE, key_g, KEY_SIZE);
  calc_power_uint8(key_g, key_a, key_p, incp->data + KEY_SIZE * 2);
  ((incp_header_t *)incp)->payload_length = 3 * KEY_SIZE;
  incp->data[3 * KEY_SIZE] = 0;
  ((ip_header_t *)ip)->length = sizeof(ip_header_t) + sizeof(incp_header_t) + 3 * KEY_SIZE;
  sw_send(ip, port);
}

// load g^b;
int action_load_b(ip_pcb_t *ip, int port) {
  sw_send(ip, port);
  calc_pre_send(ip, port);
  printf("--> %s\n", __FUNCTION__);
  return 0;
  uint8 key_tmp[KEY_LENGTH];
  in_pcb_t *incp = (in_pcb_t *)(ip->data);
  calc_generate_rand_less_len_uint8(key_p, 5, key_tmp);
  calc_power_uint8(key_g, key_tmp, key_p, incp->data);
  ((incp_header_t *)incp)->payload_length = KEY_SIZE;
  incp->data[KEY_SIZE] = 0;
  ((ip_header_t *)ip)->length = sizeof(ip_header_t) + sizeof(incp_header_t) + KEY_SIZE;
  sw_send(ip, port);
}

int action_save_a(ip_pcb_t *ip, int port) {
  in_pcb_t *incp = (in_pcb_t *)(ip->data);
  agg_p = 0;
  total_packets = (incp->incp_head).seq_num;
  sw_send(ip, port);
  printf("--> %s, tot = %d\n", __FUNCTION__, total_packets);
  return 0;
  memcpy(key_p, ip->data, KEY_SIZE);
  memcpy(key_g, ip->data + KEY_SIZE, KEY_SIZE);
  memcpy(key_a, ip->data + 2 * KEY_SIZE, KEY_SIZE);
  ((incp_header_t *)incp)->payload_length = 0;
  incp->data[0] = 0;
  ((ip_header_t *)ip)->length = sizeof(ip_header_t) + sizeof(incp_header_t);
  sw_send(ip, port);
}

int action_generate_key(ip_pcb_t *ip, int port) {
  sw_send(ip, port);
  calc_pre_send(ip, port);
  printf("--> %s\n", __FUNCTION__);
  return 0;
}

int action_save_total(ip_pcb_t *ip, int port) {
  in_pcb_t *incp = (in_pcb_t *)(ip->data);
  agg_p = 0;
  total_packets = (incp->incp_head).seq_num / INCP_PAYLOAD +
    ((incp->incp_head).seq_num % INCP_PAYLOAD != 0);
  sw_send(ip, port);
  printf("--> %s, tot = %d\n", __FUNCTION__, total_packets);
  return 0;
}

#endif // _ACTION_H_
